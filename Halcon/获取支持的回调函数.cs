//
//  File generated by HDevelop for HALCON/DOTNET (C#) Version 10.0
//

using HalconDotNet;

public partial class HDevelopExport
{
#if !NO_EXPORT_APP_MAIN
  public HDevelopExport()
  {
    // Default settings used in HDevelop 
    HOperatorSet.SetSystem("do_low_error", "false");
    action();
  }
#endif

  // Procedures 
  // Chapter: Graphics / Text
  // Short Description: This procedure writes a text message.
  public void disp_message (HTuple hv_WindowHandle, HTuple hv_String, HTuple hv_CoordSystem, 
      HTuple hv_Row, HTuple hv_Column, HTuple hv_Color, HTuple hv_Box)
  {


    // Local control variables 

    HTuple hv_Red, hv_Green, hv_Blue, hv_Row1Part;
    HTuple hv_Column1Part, hv_Row2Part, hv_Column2Part, hv_RowWin;
    HTuple hv_ColumnWin, hv_WidthWin, hv_HeightWin, hv_MaxAscent;
    HTuple hv_MaxDescent, hv_MaxWidth, hv_MaxHeight, hv_R1=new HTuple();
    HTuple hv_C1=new HTuple(), hv_FactorRow=new HTuple(), hv_FactorColumn=new HTuple();
    HTuple hv_Width=new HTuple(), hv_Index=new HTuple(), hv_Ascent=new HTuple();
    HTuple hv_Descent=new HTuple(), hv_W=new HTuple(), hv_H=new HTuple();
    HTuple hv_FrameHeight=new HTuple(), hv_FrameWidth=new HTuple();
    HTuple hv_R2=new HTuple(), hv_C2=new HTuple(), hv_DrawMode=new HTuple();
    HTuple hv_Exception=new HTuple(), hv_CurrentColor=new HTuple();

    HTuple   hv_Color_COPY_INP_TMP = hv_Color.Clone();
    HTuple   hv_Column_COPY_INP_TMP = hv_Column.Clone();
    HTuple   hv_Row_COPY_INP_TMP = hv_Row.Clone();
    HTuple   hv_String_COPY_INP_TMP = hv_String.Clone();

    // Initialize local and output iconic variables 

    //This procedure displays text in a graphics window.
    //
    //Input parameters:
    //WindowHandle: The WindowHandle of the graphics window, where
    //   the message should be displayed
    //String: A tuple of strings containing the text message to be displayed
    //CoordSystem: If set to 'window', the text position is given
    //   with respect to the window coordinate system.
    //   If set to 'image', image coordinates are used.
    //   (This may be useful in zoomed images.)
    //Row: The row coordinate of the desired text position
    //   If set to -1, a default value of 12 is used.
    //Column: The column coordinate of the desired text position
    //   If set to -1, a default value of 12 is used.
    //Color: defines the color of the text as string.
    //   If set to [], '' or 'auto' the currently set color is used.
    //   If a tuple of strings is passed, the colors are used cyclically
    //   for each new textline.
    //Box: If set to 'true', the text is written within a white box.
    //
    //prepare window
    HOperatorSet.GetRgb(hv_WindowHandle, out hv_Red, out hv_Green, out hv_Blue);
    HOperatorSet.GetPart(hv_WindowHandle, out hv_Row1Part, out hv_Column1Part, out hv_Row2Part, 
        out hv_Column2Part);
    HOperatorSet.GetWindowExtents(hv_WindowHandle, out hv_RowWin, out hv_ColumnWin, 
        out hv_WidthWin, out hv_HeightWin);
    HOperatorSet.SetPart(hv_WindowHandle, 0, 0, hv_HeightWin-1, hv_WidthWin-1);
    //
    //default settings
    if ((int)(new HTuple(hv_Row_COPY_INP_TMP.TupleEqual(-1))) != 0)
    {
      hv_Row_COPY_INP_TMP = 12;
    }
    if ((int)(new HTuple(hv_Column_COPY_INP_TMP.TupleEqual(-1))) != 0)
    {
      hv_Column_COPY_INP_TMP = 12;
    }
    if ((int)(new HTuple(hv_Color_COPY_INP_TMP.TupleEqual(new HTuple()))) != 0)
    {
      hv_Color_COPY_INP_TMP = "";
    }
    //
    hv_String_COPY_INP_TMP = (((""+hv_String_COPY_INP_TMP)+"")).TupleSplit("\n");
    //
    //Estimate extentions of text depending on font size.
    HOperatorSet.GetFontExtents(hv_WindowHandle, out hv_MaxAscent, out hv_MaxDescent, 
        out hv_MaxWidth, out hv_MaxHeight);
    if ((int)(new HTuple(hv_CoordSystem.TupleEqual("window"))) != 0)
    {
      hv_R1 = hv_Row_COPY_INP_TMP.Clone();
      hv_C1 = hv_Column_COPY_INP_TMP.Clone();
    }
    else
    {
      //transform image to window coordinates
      hv_FactorRow = (1.0*hv_HeightWin)/((hv_Row2Part-hv_Row1Part)+1);
      hv_FactorColumn = (1.0*hv_WidthWin)/((hv_Column2Part-hv_Column1Part)+1);
      hv_R1 = ((hv_Row_COPY_INP_TMP-hv_Row1Part)+0.5)*hv_FactorRow;
      hv_C1 = ((hv_Column_COPY_INP_TMP-hv_Column1Part)+0.5)*hv_FactorColumn;
    }
    //
    //display text box depending on text size
    if ((int)(new HTuple(hv_Box.TupleEqual("true"))) != 0)
    {
      //calculate box extents
      hv_String_COPY_INP_TMP = (" "+hv_String_COPY_INP_TMP)+" ";
      hv_Width = new HTuple();
      for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_String_COPY_INP_TMP.TupleLength()
          ))-1); hv_Index = (int)hv_Index + 1)
      {
        HOperatorSet.GetStringExtents(hv_WindowHandle, hv_String_COPY_INP_TMP.TupleSelect(
            hv_Index), out hv_Ascent, out hv_Descent, out hv_W, out hv_H);
        hv_Width = hv_Width.TupleConcat(hv_W);
      }
      hv_FrameHeight = hv_MaxHeight*(new HTuple(hv_String_COPY_INP_TMP.TupleLength()
          ));
      hv_FrameWidth = (((new HTuple(0)).TupleConcat(hv_Width))).TupleMax();
      hv_R2 = hv_R1+hv_FrameHeight;
      hv_C2 = hv_C1+hv_FrameWidth;
      //display rectangles
      HOperatorSet.GetDraw(hv_WindowHandle, out hv_DrawMode);
      HOperatorSet.SetDraw(hv_WindowHandle, "fill");
      HOperatorSet.SetColor(hv_WindowHandle, "light gray");
      HOperatorSet.DispRectangle1(hv_WindowHandle, hv_R1+3, hv_C1+3, hv_R2+3, hv_C2+3);
      HOperatorSet.SetColor(hv_WindowHandle, "white");
      HOperatorSet.DispRectangle1(hv_WindowHandle, hv_R1, hv_C1, hv_R2, hv_C2);
      HOperatorSet.SetDraw(hv_WindowHandle, hv_DrawMode);
    }
    else if ((int)(new HTuple(hv_Box.TupleNotEqual("false"))) != 0)
    {
      hv_Exception = "Wrong value of control parameter Box";
      throw new HalconException(hv_Exception);
    }
    //Write text.
    for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_String_COPY_INP_TMP.TupleLength()
        ))-1); hv_Index = (int)hv_Index + 1)
    {
      hv_CurrentColor = hv_Color_COPY_INP_TMP.TupleSelect(hv_Index%(new HTuple(hv_Color_COPY_INP_TMP.TupleLength()
          )));
      if ((int)((new HTuple(hv_CurrentColor.TupleNotEqual(""))).TupleAnd(new HTuple(hv_CurrentColor.TupleNotEqual(
          "auto")))) != 0)
      {
        HOperatorSet.SetColor(hv_WindowHandle, hv_CurrentColor);
      }
      else
      {
        HOperatorSet.SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
      }
      hv_Row_COPY_INP_TMP = hv_R1+(hv_MaxHeight*hv_Index);
      HOperatorSet.SetTposition(hv_WindowHandle, hv_Row_COPY_INP_TMP, hv_C1);
      HOperatorSet.WriteString(hv_WindowHandle, hv_String_COPY_INP_TMP.TupleSelect(
          hv_Index));
    }
    //reset changed window settings
    HOperatorSet.SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
    HOperatorSet.SetPart(hv_WindowHandle, hv_Row1Part, hv_Column1Part, hv_Row2Part, 
        hv_Column2Part);

    return;
  }

  // Main procedure 
  private void action()
  {

    // Local iconic variables 

    HObject ho_Image=null;


    // Local control variables 

    HTuple hv_WindowHandle, hv_AcqHandle, hv_Index;
    HTuple hv_Ex=new HTuple();

    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Image);

    try
    {
      //Code generated by Image Acquisition 01
      //Attention: The initialization may fail in case parameters need to
      //be set in a specific order (e.g., image resolution vs. offset).
      HOperatorSet.SetWindowAttr("background_color","black");
      HOperatorSet.OpenWindow(0,0,512,512,0,"","",out hv_WindowHandle);
      HDevWindowStack.Push(hv_WindowHandle);
      HOperatorSet.OpenFramegrabber("GigEVision", 0, 0, 0, 0, 0, 0, "progressive", 
          -1, "default", -1, "false", "default", "Cam_Up", 0, -1, out hv_AcqHandle);
      HOperatorSet.SetFramegrabberParam(hv_AcqHandle, "TriggerSelector", "FrameStart");
      HOperatorSet.SetFramegrabberParam(hv_AcqHandle, "grab_timeout", 10000);
      HOperatorSet.SetFramegrabberParam(hv_AcqHandle, "TriggerMode", "On");
      HOperatorSet.SetFramegrabberParam(hv_AcqHandle, "TriggerSource", "Line1");
      HOperatorSet.GrabImageStart(hv_AcqHandle, -1);
      hv_Index = 1;
      while ((int)(1) != 0)
      {
        try
        {
          ho_Image.Dispose();
          HOperatorSet.GrabImageAsync(out ho_Image, hv_AcqHandle, -1);
          hv_Index = hv_Index+1;
          disp_message(hv_WindowHandle, hv_Index, "window", 12, 12, "black", "true");
        }
        // catch (Ex) 
        catch (HalconException HDevExpDefaultException1)
        {
          HDevExpDefaultException1.ToHTuple(out hv_Ex);

        }

        //Do something
      }
      HOperatorSet.CloseFramegrabber(hv_AcqHandle);

    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_Image.Dispose();

      throw HDevExpDefaultException;
    }
    ho_Image.Dispose();

  }


}
#if !NO_EXPORT_APP_MAIN
public class HDevelopExportApp
{
  static void Main(string[] args)
  {
    new HDevelopExport();
  }
}
#endif

