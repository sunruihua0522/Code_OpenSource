//
//  File generated by HDevelop for HALCON/DOTNET (C#) Version 10.0
//

using HalconDotNet;

public partial class HDevelopExport
{
#if !NO_EXPORT_APP_MAIN
  public HDevelopExport()
  {
    // Default settings used in HDevelop 
    HOperatorSet.SetSystem("do_low_error", "false");
    action();
  }
#endif

  public void HDevelopStop()
  {
  }

  // Procedures 
  // External procedures 
  // Chapter: Develop
  // Short Description: Open a new graphics window that preserves the aspect ratio of the given image.
  public void dev_open_window_fit_image (HObject ho_Image, HTuple hv_Row, HTuple hv_Column, 
      HTuple hv_WidthLimit, HTuple hv_HeightLimit, out HTuple hv_WindowHandle)
  {



    // Local control variables 

    HTuple hv_MinWidth=new HTuple(), hv_MaxWidth=new HTuple();
    HTuple hv_MinHeight=new HTuple(), hv_MaxHeight=new HTuple();
    HTuple hv_ResizeFactor, hv_ImageWidth, hv_ImageHeight;
    HTuple hv_TempWidth, hv_TempHeight, hv_WindowWidth, hv_WindowHeight;

    // Initialize local and output iconic variables 

    //This procedure opens a new graphics window and adjusts the size
    //such that it fits into the limits specified by WidthLimit
    //and HeightLimit, but also maintains the correct image aspect ratio.
    //
    //If it is impossible to match the minimum and maximum extent requirements
    //at the same time (f.e. if the image is very long but narrow),
    //the maximum value gets a higher priority,
    //
    //Parse input tuple WidthLimit
    if ((int)((new HTuple((new HTuple(hv_WidthLimit.TupleLength())).TupleEqual(0))).TupleOr(
        new HTuple(hv_WidthLimit.TupleLess(0)))) != 0)
    {
      hv_MinWidth = 500;
      hv_MaxWidth = 800;
    }
    else if ((int)(new HTuple((new HTuple(hv_WidthLimit.TupleLength())).TupleEqual(
        1))) != 0)
    {
      hv_MinWidth = 0;
      hv_MaxWidth = hv_WidthLimit.Clone();
    }
    else
    {
      hv_MinWidth = hv_WidthLimit[0];
      hv_MaxWidth = hv_WidthLimit[1];
    }
    //Parse input tuple HeightLimit
    if ((int)((new HTuple((new HTuple(hv_HeightLimit.TupleLength())).TupleEqual(0))).TupleOr(
        new HTuple(hv_HeightLimit.TupleLess(0)))) != 0)
    {
      hv_MinHeight = 400;
      hv_MaxHeight = 600;
    }
    else if ((int)(new HTuple((new HTuple(hv_HeightLimit.TupleLength())).TupleEqual(
        1))) != 0)
    {
      hv_MinHeight = 0;
      hv_MaxHeight = hv_HeightLimit.Clone();
    }
    else
    {
      hv_MinHeight = hv_HeightLimit[0];
      hv_MaxHeight = hv_HeightLimit[1];
    }
    //
    //Test, if window size has to be changed.
    hv_ResizeFactor = 1;
    HOperatorSet.GetImageSize(ho_Image, out hv_ImageWidth, out hv_ImageHeight);
    //First, expand window to the minimum extents (if necessary).
    if ((int)((new HTuple(hv_MinWidth.TupleGreater(hv_ImageWidth))).TupleOr(new HTuple(hv_MinHeight.TupleGreater(
        hv_ImageHeight)))) != 0)
    {
      hv_ResizeFactor = (((((hv_MinWidth.TupleReal())/hv_ImageWidth)).TupleConcat(
          (hv_MinHeight.TupleReal())/hv_ImageHeight))).TupleMax();
    }
    hv_TempWidth = hv_ImageWidth*hv_ResizeFactor;
    hv_TempHeight = hv_ImageHeight*hv_ResizeFactor;
    //Then, shrink window to maximum extents (if necessary).
    if ((int)((new HTuple(hv_MaxWidth.TupleLess(hv_TempWidth))).TupleOr(new HTuple(hv_MaxHeight.TupleLess(
        hv_TempHeight)))) != 0)
    {
      hv_ResizeFactor = hv_ResizeFactor*((((((hv_MaxWidth.TupleReal())/hv_TempWidth)).TupleConcat(
          (hv_MaxHeight.TupleReal())/hv_TempHeight))).TupleMin());
    }
    hv_WindowWidth = hv_ImageWidth*hv_ResizeFactor;
    hv_WindowHeight = hv_ImageHeight*hv_ResizeFactor;
    //Resize window
    HOperatorSet.SetWindowAttr("background_color","black");
    HOperatorSet.OpenWindow(hv_Row,hv_Column,hv_WindowWidth,hv_WindowHeight,0,"","",out hv_WindowHandle);
    HDevWindowStack.Push(hv_WindowHandle);
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.SetPart(HDevWindowStack.GetActive(), 0, 0, hv_ImageHeight-1, hv_ImageWidth-1);
    }

    return;
  }

  // Chapter: Filter / Arithmetic
  // Short Description: Scale the gray values of an image from the interval [Min,Max] to [0,255]
  public void scale_image_range (HObject ho_Image, out HObject ho_ImageScaled, HTuple hv_Min, 
      HTuple hv_Max)
  {



      // Stack for temporary objects 
      HObject[] OTemp = new HObject[20];
      long SP_O = 0;

      // Local iconic variables 

      HObject ho_SelectedChannel=null, ho_LowerRegion=null;
      HObject ho_UpperRegion=null;

      HObject ho_Image_COPY_INP_TMP;
      ho_Image_COPY_INP_TMP = ho_Image.CopyObj(1,-1);


      // Local control variables 

      HTuple hv_LowerLimit=new HTuple(), hv_UpperLimit=new HTuple();
      HTuple hv_Mult, hv_Add, hv_Channels, hv_Index, hv_MinGray=new HTuple();
      HTuple hv_MaxGray=new HTuple(), hv_Range=new HTuple();

      HTuple   hv_Max_COPY_INP_TMP = hv_Max.Clone();
      HTuple   hv_Min_COPY_INP_TMP = hv_Min.Clone();

      // Initialize local and output iconic variables 
      HOperatorSet.GenEmptyObj(out ho_ImageScaled);
      HOperatorSet.GenEmptyObj(out ho_SelectedChannel);
      HOperatorSet.GenEmptyObj(out ho_LowerRegion);
      HOperatorSet.GenEmptyObj(out ho_UpperRegion);

    //Convenience procedure to scale the gray values of the
    //input image Image from the interval [Min,Max]
    //to the interval [0,255] (default).
    //Gray values < 0 or > 255 (after scaling) are clipped.
    //
    //If the image shall be scaled to an interval different from [0,255],
    //this can be achieved by passing tuples with 2 values [From, To]
    //as Min and Max.
    //Example:
    //scale_image_range(Image:ImageScaled:[100,50],[200,250])
    //maps the gray values of Image from the interval [100,200] to [50,250].
    //All other gray values will be clipped.
    //
    //input parameters:
    //Image: the input image
    //Min: the minimum gray value which will be mapped to 0
    //     If a tuple with two values is given, the first value will
    //     be mapped to the second value.
    //Max: The maximum gray value which will be mapped to 255
    //     If a tuple with two values is given, the first value will
    //     be mapped to the second value.
    //
    //output parameter:
    //ImageScale: the resulting scaled image
    //
    if ((int)(new HTuple((new HTuple(hv_Min_COPY_INP_TMP.TupleLength())).TupleEqual(
        2))) != 0)
    {
      hv_LowerLimit = hv_Min_COPY_INP_TMP[1];
      hv_Min_COPY_INP_TMP = hv_Min_COPY_INP_TMP[0];
    }
    else
    {
      hv_LowerLimit = 0.0;
    }
    if ((int)(new HTuple((new HTuple(hv_Max_COPY_INP_TMP.TupleLength())).TupleEqual(
        2))) != 0)
    {
      hv_UpperLimit = hv_Max_COPY_INP_TMP[1];
      hv_Max_COPY_INP_TMP = hv_Max_COPY_INP_TMP[0];
    }
    else
    {
      hv_UpperLimit = 255.0;
    }
    //
    //Calculate scaling parameters
    hv_Mult = (((hv_UpperLimit-hv_LowerLimit)).TupleReal())/(hv_Max_COPY_INP_TMP-hv_Min_COPY_INP_TMP);
    hv_Add = ((-hv_Mult)*hv_Min_COPY_INP_TMP)+hv_LowerLimit;
    //
    //Scale image
    OTemp[SP_O] = ho_Image_COPY_INP_TMP.CopyObj(1,-1);
    SP_O++;
    ho_Image_COPY_INP_TMP.Dispose();
    HOperatorSet.ScaleImage(OTemp[SP_O-1], out ho_Image_COPY_INP_TMP, hv_Mult, hv_Add);
    OTemp[SP_O-1].Dispose();
    SP_O = 0;
    //
    //Clip gray values if necessary
    //This must be done for each channel separately
    HOperatorSet.CountChannels(ho_Image_COPY_INP_TMP, out hv_Channels);
    for (hv_Index=1; hv_Index.Continue(hv_Channels, 1); hv_Index = hv_Index.TupleAdd(1))
    {
      ho_SelectedChannel.Dispose();
      HOperatorSet.AccessChannel(ho_Image_COPY_INP_TMP, out ho_SelectedChannel, hv_Index);
      HOperatorSet.MinMaxGray(ho_SelectedChannel, ho_SelectedChannel, 0, out hv_MinGray, 
          out hv_MaxGray, out hv_Range);
      ho_LowerRegion.Dispose();
      HOperatorSet.Threshold(ho_SelectedChannel, out ho_LowerRegion, ((hv_MinGray.TupleConcat(
          hv_LowerLimit))).TupleMin(), hv_LowerLimit);
      ho_UpperRegion.Dispose();
      HOperatorSet.Threshold(ho_SelectedChannel, out ho_UpperRegion, hv_UpperLimit, 
          ((hv_UpperLimit.TupleConcat(hv_MaxGray))).TupleMax());
      OTemp[SP_O] = ho_SelectedChannel.CopyObj(1,-1);
      SP_O++;
      ho_SelectedChannel.Dispose();
      HOperatorSet.PaintRegion(ho_LowerRegion, OTemp[SP_O-1], out ho_SelectedChannel, 
          hv_LowerLimit, "fill");
      OTemp[SP_O-1].Dispose();
      SP_O = 0;
      OTemp[SP_O] = ho_SelectedChannel.CopyObj(1,-1);
      SP_O++;
      ho_SelectedChannel.Dispose();
      HOperatorSet.PaintRegion(ho_UpperRegion, OTemp[SP_O-1], out ho_SelectedChannel, 
          hv_UpperLimit, "fill");
      OTemp[SP_O-1].Dispose();
      SP_O = 0;
      if ((int)(new HTuple(hv_Index.TupleEqual(1))) != 0)
      {
        ho_ImageScaled.Dispose();
        HOperatorSet.CopyObj(ho_SelectedChannel, out ho_ImageScaled, 1, 1);
      }
      else
      {
        OTemp[SP_O] = ho_ImageScaled.CopyObj(1,-1);
        SP_O++;
        ho_ImageScaled.Dispose();
        HOperatorSet.AppendChannel(OTemp[SP_O-1], ho_SelectedChannel, out ho_ImageScaled
            );
        OTemp[SP_O-1].Dispose();
        SP_O = 0;
      }
    }
    ho_Image_COPY_INP_TMP.Dispose();
    ho_SelectedChannel.Dispose();
    ho_LowerRegion.Dispose();
    ho_UpperRegion.Dispose();

    return;
  }

  // Main procedure 
  private void action()
  {

    // Local iconic variables 

    HObject ho_Image9=null, ho_ImageScaled=null;


    // Local control variables 

    HTuple hv_ModelID, hv_Index, hv_WindowHandle=new HTuple();
    HTuple hv_Row=new HTuple(), hv_Column=new HTuple(), hv_Angle=new HTuple();
    HTuple hv_Score=new HTuple();

    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Image9);
    HOperatorSet.GenEmptyObj(out ho_ImageScaled);

    HOperatorSet.ReadShapeModel("C:/Users/GPAP/Desktop/1.shm", out hv_ModelID);
    for (hv_Index=4; (int)hv_Index<=9; hv_Index = (int)hv_Index + 1)
    {
      ho_Image9.Dispose();
      HOperatorSet.ReadImage(out ho_Image9, ("C:/Users/GPAP/Desktop/"+hv_Index)+".jpg");
      ho_ImageScaled.Dispose();
      scale_image_range(ho_Image9, out ho_ImageScaled, 30, 70);

      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.CloseWindow(HDevWindowStack.Pop());
      }
      dev_open_window_fit_image(ho_Image9, 0, 0, -1, -1, out hv_WindowHandle);

      HOperatorSet.FindShapeModel(ho_ImageScaled, hv_ModelID, -0.39, 0.78, 0.5, 1, 
          0.5, "least_squares", 0, 0.9, out hv_Row, out hv_Column, out hv_Angle, 
          out hv_Score);
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispObj(ho_Image9, HDevWindowStack.GetActive());
      }
      HOperatorSet.DispCross(hv_WindowHandle, hv_Row, hv_Column, 36, hv_Angle);
      HDevelopStop();
    }
    HOperatorSet.ClearShapeModel(hv_ModelID);








    ho_Image9.Dispose();
    ho_ImageScaled.Dispose();

  }


}
#if !NO_EXPORT_APP_MAIN
public class HDevelopExportApp
{
  static void Main(string[] args)
  {
    new HDevelopExport();
  }
}
#endif

